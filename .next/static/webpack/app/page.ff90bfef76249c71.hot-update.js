"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./types/index.ts":
/*!************************!*\
  !*** ./types/index.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToWordLikeComment: function() { return /* binding */ convertToWordLikeComment; }\n/* harmony export */ });\n// Utility function to convert LegalComment to Comment for WordLikeEditor\nfunction convertToWordLikeComment(legalComment, fullText) {\n    const severityMap = {\n        \"Must Change\": \"high\",\n        \"Recommend to Change\": \"medium\",\n        \"Negotiable\": \"low\"\n    };\n    // Calculate start and end positions using context-based matching\n    const { start, end } = findTextPosition(legalComment, fullText);\n    return {\n        id: legalComment.comment_id,\n        text: \"\".concat(legalComment.comment_title, \"\\n\\n\").concat(legalComment.comment_details, \"\\n\\nRecommendation: \").concat(legalComment.recommendation),\n        author: \"AI Legal Assistant\",\n        start,\n        end,\n        severity: severityMap[legalComment.severity]\n    };\n}\n// Helper function to find text position using context matching\nfunction findTextPosition(comment, fullText) {\n    const { context_before, original_text, context_after } = comment;\n    // Try different search strategies in order of reliability\n    // Strategy 1: Full context match (most reliable)\n    if (context_before && context_after) {\n        const fullPattern = \"\".concat(context_before).concat(original_text).concat(context_after);\n        const fullMatch = fullText.indexOf(fullPattern);\n        if (fullMatch !== -1) {\n            const start = fullMatch + context_before.length;\n            return {\n                start,\n                end: start + original_text.length\n            };\n        }\n    }\n    // Strategy 2: Before context + original text\n    if (context_before) {\n        const beforePattern = \"\".concat(context_before).concat(original_text);\n        const beforeMatch = fullText.indexOf(beforePattern);\n        if (beforeMatch !== -1) {\n            const start = beforeMatch + context_before.length;\n            return {\n                start,\n                end: start + original_text.length\n            };\n        }\n    }\n    // Strategy 3: Original text + after context\n    if (context_after) {\n        const afterPattern = \"\".concat(original_text).concat(context_after);\n        const afterMatch = fullText.indexOf(afterPattern);\n        if (afterMatch !== -1) {\n            return {\n                start: afterMatch,\n                end: afterMatch + original_text.length\n            };\n        }\n    }\n    // Strategy 4: Exact text match (fallback)\n    const exactMatch = fullText.indexOf(original_text);\n    if (exactMatch !== -1) {\n        return {\n            start: exactMatch,\n            end: exactMatch + original_text.length\n        };\n    }\n    // Strategy 5: Fuzzy matching for similar text (last resort)\n    const words = original_text.trim().split(/\\s+/);\n    if (words.length > 1) {\n        // Try to find a substring with most of the words\n        const firstFew = words.slice(0, Math.ceil(words.length / 2)).join(\" \");\n        const fuzzyMatch = fullText.indexOf(firstFew);\n        if (fuzzyMatch !== -1) {\n            return {\n                start: fuzzyMatch,\n                end: fuzzyMatch + original_text.length\n            };\n        }\n    }\n    // If all else fails, return position 0 (shouldn't happen with good context)\n    console.warn(\"Could not find text position for comment:\", comment.comment_id);\n    return {\n        start: 0,\n        end: original_text.length\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsNkNBQTZDdkIsUUFBUVAsVUFBVTtJQUM1RSxPQUFPO1FBQUVKLE9BQU87UUFBR0MsS0FBS1ksY0FBY0ssTUFBTTtJQUFDO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3R5cGVzL2luZGV4LnRzP2RmMmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBMZWdhbENvbW1lbnQge1xuICBjb21tZW50X2lkOiBzdHJpbmdcbiAgY29udGV4dF9iZWZvcmU6IHN0cmluZ1xuICBvcmlnaW5hbF90ZXh0OiBzdHJpbmdcbiAgY29udGV4dF9hZnRlcjogc3RyaW5nXG4gIHNldmVyaXR5OiAnTXVzdCBDaGFuZ2UnIHwgJ1JlY29tbWVuZCB0byBDaGFuZ2UnIHwgJ05lZ290aWFibGUnXG4gIGNvbW1lbnRfdGl0bGU6IHN0cmluZ1xuICBjb21tZW50X2RldGFpbHM6IHN0cmluZ1xuICByZWNvbW1lbmRhdGlvbjogc3RyaW5nXG59XG5cbi8vIENvbW1lbnQgaW50ZXJmYWNlIGZvciBXb3JkTGlrZUVkaXRvciBjb21wb25lbnRcbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWVudCB7XG4gIGlkOiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG4gIGF1dGhvcjogc3RyaW5nXG4gIHN0YXJ0OiBudW1iZXJcbiAgZW5kOiBudW1iZXJcbiAgc2V2ZXJpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc1Jlc3VsdCB7XG4gIGRvY3VtZW50X2lkOiBzdHJpbmdcbiAgYW5hbHlzaXNfc3VtbWFyeTogc3RyaW5nXG4gIGNvbW1lbnRzOiBMZWdhbENvbW1lbnRbXVxuICBvcmlnaW5hbF90ZXh0Pzogc3RyaW5nIC8vIEFkZCBvcmlnaW5hbCB0ZXh0IGZvciBXb3JkTGlrZUVkaXRvclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVVcGxvYWRSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgdGV4dD86IHN0cmluZ1xuICBlcnJvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzUmVxdWVzdCB7XG4gIHRleHQ6IHN0cmluZ1xuICBkb2N1bWVudFR5cGU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeXN0ZW1Db25maWcge1xuICBzeXN0ZW1Qcm9tcHQ6IHN0cmluZ1xuICB0ZW1wZXJhdHVyZTogbnVtYmVyXG4gIHRvcFA6IG51bWJlclxuICBtb2RlbDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFNldmVyaXR5TGV2ZWwgPSAnTXVzdCBDaGFuZ2UnIHwgJ1JlY29tbWVuZCB0byBDaGFuZ2UnIHwgJ05lZ290aWFibGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uUmVzcG9uc2U8VCA9IGFueT4ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGRhdGE/OiBUXG4gIGVycm9yPzogc3RyaW5nXG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29udmVydCBMZWdhbENvbW1lbnQgdG8gQ29tbWVudCBmb3IgV29yZExpa2VFZGl0b3JcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Xb3JkTGlrZUNvbW1lbnQobGVnYWxDb21tZW50OiBMZWdhbENvbW1lbnQsIGZ1bGxUZXh0OiBzdHJpbmcpOiBDb21tZW50IHtcbiAgY29uc3Qgc2V2ZXJpdHlNYXA6IFJlY29yZDxTZXZlcml0eUxldmVsLCBDb21tZW50WydzZXZlcml0eSddPiA9IHtcbiAgICAnTXVzdCBDaGFuZ2UnOiAnaGlnaCcsXG4gICAgJ1JlY29tbWVuZCB0byBDaGFuZ2UnOiAnbWVkaXVtJyxcbiAgICAnTmVnb3RpYWJsZSc6ICdsb3cnXG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgdXNpbmcgY29udGV4dC1iYXNlZCBtYXRjaGluZ1xuICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGZpbmRUZXh0UG9zaXRpb24obGVnYWxDb21tZW50LCBmdWxsVGV4dClcblxuICByZXR1cm4ge1xuICAgIGlkOiBsZWdhbENvbW1lbnQuY29tbWVudF9pZCxcbiAgICB0ZXh0OiBgJHtsZWdhbENvbW1lbnQuY29tbWVudF90aXRsZX1cXG5cXG4ke2xlZ2FsQ29tbWVudC5jb21tZW50X2RldGFpbHN9XFxuXFxuUmVjb21tZW5kYXRpb246ICR7bGVnYWxDb21tZW50LnJlY29tbWVuZGF0aW9ufWAsXG4gICAgYXV0aG9yOiAnQUkgTGVnYWwgQXNzaXN0YW50JyxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgc2V2ZXJpdHk6IHNldmVyaXR5TWFwW2xlZ2FsQ29tbWVudC5zZXZlcml0eV1cbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCB0ZXh0IHBvc2l0aW9uIHVzaW5nIGNvbnRleHQgbWF0Y2hpbmdcbmZ1bmN0aW9uIGZpbmRUZXh0UG9zaXRpb24oY29tbWVudDogTGVnYWxDb21tZW50LCBmdWxsVGV4dDogc3RyaW5nKTogeyBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciB9IHtcbiAgY29uc3QgeyBjb250ZXh0X2JlZm9yZSwgb3JpZ2luYWxfdGV4dCwgY29udGV4dF9hZnRlciB9ID0gY29tbWVudFxuICBcbiAgLy8gVHJ5IGRpZmZlcmVudCBzZWFyY2ggc3RyYXRlZ2llcyBpbiBvcmRlciBvZiByZWxpYWJpbGl0eVxuICBcbiAgLy8gU3RyYXRlZ3kgMTogRnVsbCBjb250ZXh0IG1hdGNoIChtb3N0IHJlbGlhYmxlKVxuICBpZiAoY29udGV4dF9iZWZvcmUgJiYgY29udGV4dF9hZnRlcikge1xuICAgIGNvbnN0IGZ1bGxQYXR0ZXJuID0gYCR7Y29udGV4dF9iZWZvcmV9JHtvcmlnaW5hbF90ZXh0fSR7Y29udGV4dF9hZnRlcn1gXG4gICAgY29uc3QgZnVsbE1hdGNoID0gZnVsbFRleHQuaW5kZXhPZihmdWxsUGF0dGVybilcbiAgICBpZiAoZnVsbE1hdGNoICE9PSAtMSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmdWxsTWF0Y2ggKyBjb250ZXh0X2JlZm9yZS5sZW5ndGhcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RyYXRlZ3kgMjogQmVmb3JlIGNvbnRleHQgKyBvcmlnaW5hbCB0ZXh0XG4gIGlmIChjb250ZXh0X2JlZm9yZSkge1xuICAgIGNvbnN0IGJlZm9yZVBhdHRlcm4gPSBgJHtjb250ZXh0X2JlZm9yZX0ke29yaWdpbmFsX3RleHR9YFxuICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gZnVsbFRleHQuaW5kZXhPZihiZWZvcmVQYXR0ZXJuKVxuICAgIGlmIChiZWZvcmVNYXRjaCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gYmVmb3JlTWF0Y2ggKyBjb250ZXh0X2JlZm9yZS5sZW5ndGhcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RyYXRlZ3kgMzogT3JpZ2luYWwgdGV4dCArIGFmdGVyIGNvbnRleHRcbiAgaWYgKGNvbnRleHRfYWZ0ZXIpIHtcbiAgICBjb25zdCBhZnRlclBhdHRlcm4gPSBgJHtvcmlnaW5hbF90ZXh0fSR7Y29udGV4dF9hZnRlcn1gXG4gICAgY29uc3QgYWZ0ZXJNYXRjaCA9IGZ1bGxUZXh0LmluZGV4T2YoYWZ0ZXJQYXR0ZXJuKVxuICAgIGlmIChhZnRlck1hdGNoICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHsgc3RhcnQ6IGFmdGVyTWF0Y2gsIGVuZDogYWZ0ZXJNYXRjaCArIG9yaWdpbmFsX3RleHQubGVuZ3RoIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFN0cmF0ZWd5IDQ6IEV4YWN0IHRleHQgbWF0Y2ggKGZhbGxiYWNrKVxuICBjb25zdCBleGFjdE1hdGNoID0gZnVsbFRleHQuaW5kZXhPZihvcmlnaW5hbF90ZXh0KVxuICBpZiAoZXhhY3RNYXRjaCAhPT0gLTEpIHtcbiAgICByZXR1cm4geyBzdGFydDogZXhhY3RNYXRjaCwgZW5kOiBleGFjdE1hdGNoICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICB9XG4gIFxuICAvLyBTdHJhdGVneSA1OiBGdXp6eSBtYXRjaGluZyBmb3Igc2ltaWxhciB0ZXh0IChsYXN0IHJlc29ydClcbiAgY29uc3Qgd29yZHMgPSBvcmlnaW5hbF90ZXh0LnRyaW0oKS5zcGxpdCgvXFxzKy8pXG4gIGlmICh3b3Jkcy5sZW5ndGggPiAxKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBzdWJzdHJpbmcgd2l0aCBtb3N0IG9mIHRoZSB3b3Jkc1xuICAgIGNvbnN0IGZpcnN0RmV3ID0gd29yZHMuc2xpY2UoMCwgTWF0aC5jZWlsKHdvcmRzLmxlbmd0aCAvIDIpKS5qb2luKCcgJylcbiAgICBjb25zdCBmdXp6eU1hdGNoID0gZnVsbFRleHQuaW5kZXhPZihmaXJzdEZldylcbiAgICBpZiAoZnV6enlNYXRjaCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBmdXp6eU1hdGNoLCBlbmQ6IGZ1enp5TWF0Y2ggKyBvcmlnaW5hbF90ZXh0Lmxlbmd0aCB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgcmV0dXJuIHBvc2l0aW9uIDAgKHNob3VsZG4ndCBoYXBwZW4gd2l0aCBnb29kIGNvbnRleHQpXG4gIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgdGV4dCBwb3NpdGlvbiBmb3IgY29tbWVudDonLCBjb21tZW50LmNvbW1lbnRfaWQpXG4gIHJldHVybiB7IHN0YXJ0OiAwLCBlbmQ6IG9yaWdpbmFsX3RleHQubGVuZ3RoIH1cbn0gIl0sIm5hbWVzIjpbImNvbnZlcnRUb1dvcmRMaWtlQ29tbWVudCIsImxlZ2FsQ29tbWVudCIsImZ1bGxUZXh0Iiwic2V2ZXJpdHlNYXAiLCJzdGFydCIsImVuZCIsImZpbmRUZXh0UG9zaXRpb24iLCJpZCIsImNvbW1lbnRfaWQiLCJ0ZXh0IiwiY29tbWVudF90aXRsZSIsImNvbW1lbnRfZGV0YWlscyIsInJlY29tbWVuZGF0aW9uIiwiYXV0aG9yIiwic2V2ZXJpdHkiLCJjb21tZW50IiwiY29udGV4dF9iZWZvcmUiLCJvcmlnaW5hbF90ZXh0IiwiY29udGV4dF9hZnRlciIsImZ1bGxQYXR0ZXJuIiwiZnVsbE1hdGNoIiwiaW5kZXhPZiIsImxlbmd0aCIsImJlZm9yZVBhdHRlcm4iLCJiZWZvcmVNYXRjaCIsImFmdGVyUGF0dGVybiIsImFmdGVyTWF0Y2giLCJleGFjdE1hdGNoIiwid29yZHMiLCJ0cmltIiwic3BsaXQiLCJmaXJzdEZldyIsInNsaWNlIiwiTWF0aCIsImNlaWwiLCJqb2luIiwiZnV6enlNYXRjaCIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/index.ts\n"));

/***/ })

});