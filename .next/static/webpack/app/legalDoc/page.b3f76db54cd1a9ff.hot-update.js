"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/legalDoc/page",{

/***/ "(app-pages-browser)/./types/index.ts":
/*!************************!*\
  !*** ./types/index.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToWordLikeComment: function() { return /* binding */ convertToWordLikeComment; }\n/* harmony export */ });\n// Utility function to convert LegalComment to Comment for WordLikeEditor\nfunction convertToWordLikeComment(legalComment, fullText) {\n    const severityMap = {\n        \"Must Change\": \"high\",\n        \"Recommend to Change\": \"medium\",\n        \"Negotiable\": \"low\"\n    };\n    // Calculate start and end positions using context-based matching\n    const { start, end } = findTextPosition(legalComment, fullText);\n    return {\n        id: legalComment.comment_id,\n        text: \"\".concat(legalComment.comment_title, \"\\n\\n\").concat(legalComment.comment_details, \"\\n\\nRecommendation: \").concat(legalComment.recommendation),\n        author: \"AI Legal Assistant\",\n        start,\n        end,\n        severity: severityMap[legalComment.severity]\n    };\n}\n// Helper function to find text position using context matching\nfunction findTextPosition(comment, fullText) {\n    const { context_before, original_text, context_after } = comment;\n    console.log(\"Finding position for comment:\", comment.comment_id);\n    console.log(\"Context before:\", JSON.stringify(context_before));\n    console.log(\"Original text:\", JSON.stringify(original_text));\n    console.log(\"Context after:\", JSON.stringify(context_after));\n    // Normalize whitespace for better matching\n    const normalizeText = (text)=>text.replace(/\\s+/g, \" \").trim();\n    const normalizedFullText = normalizeText(fullText);\n    // Try different search strategies in order of reliability\n    // Strategy 1: Full context match (most reliable)\n    if (context_before && context_after) {\n        const fullPattern = \"\".concat(context_before).concat(original_text).concat(context_after);\n        const normalizedPattern = normalizeText(fullPattern);\n        let fullMatch = fullText.indexOf(fullPattern);\n        if (fullMatch === -1) {\n            // Try with normalized whitespace\n            fullMatch = normalizedFullText.indexOf(normalizedPattern);\n            if (fullMatch !== -1) {\n                // Convert back to original text position\n                const beforeNormalized = normalizeText(context_before);\n                const beforeMatch = normalizedFullText.indexOf(beforeNormalized);\n                if (beforeMatch !== -1) {\n                    fullMatch = beforeMatch;\n                }\n            }\n        }\n        if (fullMatch !== -1) {\n            const start = fullMatch + context_before.length;\n            console.log(\"✅ Full context match found at position:\", start);\n            return {\n                start,\n                end: start + original_text.length\n            };\n        }\n    }\n    // Strategy 2: Before context + original text\n    if (context_before) {\n        const beforePattern = \"\".concat(context_before).concat(original_text);\n        let beforeMatch = fullText.indexOf(beforePattern);\n        if (beforeMatch === -1) {\n            // Try with normalized whitespace\n            const normalizedPattern = normalizeText(beforePattern);\n            beforeMatch = normalizedFullText.indexOf(normalizedPattern);\n        }\n        if (beforeMatch !== -1) {\n            const start = beforeMatch + context_before.length;\n            console.log(\"✅ Before context match found at position:\", start);\n            return {\n                start,\n                end: start + original_text.length\n            };\n        }\n    }\n    // Strategy 3: Original text + after context\n    if (context_after) {\n        const afterPattern = \"\".concat(original_text).concat(context_after);\n        let afterMatch = fullText.indexOf(afterPattern);\n        if (afterMatch === -1) {\n            // Try with normalized whitespace\n            const normalizedPattern = normalizeText(afterPattern);\n            afterMatch = normalizedFullText.indexOf(normalizedPattern);\n        }\n        if (afterMatch !== -1) {\n            console.log(\"✅ After context match found at position:\", afterMatch);\n            return {\n                start: afterMatch,\n                end: afterMatch + original_text.length\n            };\n        }\n    }\n    // Strategy 4: Exact text match (fallback)\n    let exactMatch = fullText.indexOf(original_text);\n    if (exactMatch === -1) {\n        // Try with normalized whitespace\n        const normalizedOriginal = normalizeText(original_text);\n        exactMatch = normalizedFullText.indexOf(normalizedOriginal);\n    }\n    if (exactMatch !== -1) {\n        console.log(\"✅ Exact text match found at position:\", exactMatch);\n        return {\n            start: exactMatch,\n            end: exactMatch + original_text.length\n        };\n    }\n    // Strategy 5: Fuzzy matching for similar text\n    const words = original_text.trim().split(/\\s+/);\n    if (words.length > 2) {\n        // Try to find a substring with most of the words\n        const firstHalf = words.slice(0, Math.ceil(words.length / 2)).join(\" \");\n        const secondHalf = words.slice(Math.floor(words.length / 2)).join(\" \");\n        let fuzzyMatch = fullText.indexOf(firstHalf);\n        if (fuzzyMatch === -1) {\n            fuzzyMatch = fullText.indexOf(secondHalf);\n        }\n        if (fuzzyMatch !== -1) {\n            console.log(\"✅ Fuzzy match found at position:\", fuzzyMatch);\n            return {\n                start: fuzzyMatch,\n                end: fuzzyMatch + original_text.length\n            };\n        }\n    }\n    // Strategy 6: Word-by-word search (last resort)\n    const firstWord = words[0];\n    if (firstWord && firstWord.length > 3) {\n        const wordMatch = fullText.indexOf(firstWord);\n        if (wordMatch !== -1) {\n            console.log(\"✅ First word match found at position:\", wordMatch);\n            return {\n                start: wordMatch,\n                end: wordMatch + original_text.length\n            };\n        }\n    }\n    // If all else fails, distribute comments evenly instead of position 0\n    console.warn(\"❌ Could not find text position for comment:\", comment.comment_id);\n    console.warn(\"Falling back to distributed positioning\");\n    // Use a hash of the comment ID to create consistent but distributed positioning\n    const hash = comment.comment_id.split(\"\").reduce((a, b)=>{\n        a = (a << 5) - a + b.charCodeAt(0);\n        return a & a;\n    }, 0);\n    const fallbackPosition = Math.abs(hash) % Math.max(1, Math.floor(fullText.length / 4));\n    return {\n        start: fallbackPosition,\n        end: fallbackPosition + original_text.length\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cEQsS0FBS29ELG1CQUFtQnhDLGNBQWNnQixNQUFNO0lBQUM7QUFDakYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdHlwZXMvaW5kZXgudHM/ZGYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIExlZ2FsQ29tbWVudCB7XG4gIGNvbW1lbnRfaWQ6IHN0cmluZ1xuICBjb250ZXh0X2JlZm9yZTogc3RyaW5nXG4gIG9yaWdpbmFsX3RleHQ6IHN0cmluZ1xuICBjb250ZXh0X2FmdGVyOiBzdHJpbmdcbiAgc2V2ZXJpdHk6ICdNdXN0IENoYW5nZScgfCAnUmVjb21tZW5kIHRvIENoYW5nZScgfCAnTmVnb3RpYWJsZSdcbiAgY29tbWVudF90aXRsZTogc3RyaW5nXG4gIGNvbW1lbnRfZGV0YWlsczogc3RyaW5nXG4gIHJlY29tbWVuZGF0aW9uOiBzdHJpbmdcbn1cblxuLy8gQ29tbWVudCBpbnRlcmZhY2UgZm9yIFdvcmRMaWtlRWRpdG9yIGNvbXBvbmVudFxuZXhwb3J0IGludGVyZmFjZSBDb21tZW50IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZXh0OiBzdHJpbmdcbiAgYXV0aG9yOiBzdHJpbmdcbiAgc3RhcnQ6IG51bWJlclxuICBlbmQ6IG51bWJlclxuICBzZXZlcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJ1xufVxuXG4vLyBXb3JkIGRvY3VtZW50IGNvbW1lbnQgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFdvcmRDb21tZW50IHtcbiAgaWQ6IHN0cmluZ1xuICB0ZXh0OiBzdHJpbmdcbiAgYXV0aG9yOiBzdHJpbmdcbiAgZGF0ZTogc3RyaW5nXG4gIHBvc2l0aW9uOiB7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH1cbiAgdHlwZTogJ3dvcmQtY29tbWVudCdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc1Jlc3VsdCB7XG4gIGRvY3VtZW50X2lkOiBzdHJpbmdcbiAgYW5hbHlzaXNfc3VtbWFyeTogc3RyaW5nXG4gIGNvbW1lbnRzOiBMZWdhbENvbW1lbnRbXVxuICBvcmlnaW5hbF90ZXh0Pzogc3RyaW5nIC8vIEFkZCBvcmlnaW5hbCB0ZXh0IGZvciBXb3JkTGlrZUVkaXRvclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVVcGxvYWRSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgdGV4dD86IHN0cmluZ1xuICBlcnJvcj86IHN0cmluZ1xuICB3b3JkQ29tbWVudHM/OiBXb3JkQ29tbWVudFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5hbHlzaXNSZXF1ZXN0IHtcbiAgdGV4dDogc3RyaW5nXG4gIGRvY3VtZW50VHlwZT86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUNvbmZpZyB7XG4gIHN5c3RlbVByb21wdDogc3RyaW5nXG4gIHRlbXBlcmF0dXJlOiBudW1iZXJcbiAgdG9wUDogbnVtYmVyXG4gIG1vZGVsOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgU2V2ZXJpdHlMZXZlbCA9ICdNdXN0IENoYW5nZScgfCAnUmVjb21tZW5kIHRvIENoYW5nZScgfCAnTmVnb3RpYWJsZSdcblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25SZXNwb25zZTxUID0gYW55PiB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgZGF0YT86IFRcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBjb252ZXJ0IExlZ2FsQ29tbWVudCB0byBDb21tZW50IGZvciBXb3JkTGlrZUVkaXRvclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dvcmRMaWtlQ29tbWVudChsZWdhbENvbW1lbnQ6IExlZ2FsQ29tbWVudCwgZnVsbFRleHQ6IHN0cmluZyk6IENvbW1lbnQge1xuICBjb25zdCBzZXZlcml0eU1hcDogUmVjb3JkPFNldmVyaXR5TGV2ZWwsIENvbW1lbnRbJ3NldmVyaXR5J10+ID0ge1xuICAgICdNdXN0IENoYW5nZSc6ICdoaWdoJyxcbiAgICAnUmVjb21tZW5kIHRvIENoYW5nZSc6ICdtZWRpdW0nLFxuICAgICdOZWdvdGlhYmxlJzogJ2xvdydcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyB1c2luZyBjb250ZXh0LWJhc2VkIG1hdGNoaW5nXG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZmluZFRleHRQb3NpdGlvbihsZWdhbENvbW1lbnQsIGZ1bGxUZXh0KVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IGxlZ2FsQ29tbWVudC5jb21tZW50X2lkLFxuICAgIHRleHQ6IGAke2xlZ2FsQ29tbWVudC5jb21tZW50X3RpdGxlfVxcblxcbiR7bGVnYWxDb21tZW50LmNvbW1lbnRfZGV0YWlsc31cXG5cXG5SZWNvbW1lbmRhdGlvbjogJHtsZWdhbENvbW1lbnQucmVjb21tZW5kYXRpb259YCxcbiAgICBhdXRob3I6ICdBSSBMZWdhbCBBc3Npc3RhbnQnLFxuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBzZXZlcml0eTogc2V2ZXJpdHlNYXBbbGVnYWxDb21tZW50LnNldmVyaXR5XVxuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmaW5kIHRleHQgcG9zaXRpb24gdXNpbmcgY29udGV4dCBtYXRjaGluZ1xuZnVuY3Rpb24gZmluZFRleHRQb3NpdGlvbihjb21tZW50OiBMZWdhbENvbW1lbnQsIGZ1bGxUZXh0OiBzdHJpbmcpOiB7IHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyIH0ge1xuICBjb25zdCB7IGNvbnRleHRfYmVmb3JlLCBvcmlnaW5hbF90ZXh0LCBjb250ZXh0X2FmdGVyIH0gPSBjb21tZW50XG4gIFxuICBjb25zb2xlLmxvZygnRmluZGluZyBwb3NpdGlvbiBmb3IgY29tbWVudDonLCBjb21tZW50LmNvbW1lbnRfaWQpXG4gIGNvbnNvbGUubG9nKCdDb250ZXh0IGJlZm9yZTonLCBKU09OLnN0cmluZ2lmeShjb250ZXh0X2JlZm9yZSkpXG4gIGNvbnNvbGUubG9nKCdPcmlnaW5hbCB0ZXh0OicsIEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsX3RleHQpKVxuICBjb25zb2xlLmxvZygnQ29udGV4dCBhZnRlcjonLCBKU09OLnN0cmluZ2lmeShjb250ZXh0X2FmdGVyKSlcbiAgXG4gIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlIGZvciBiZXR0ZXIgbWF0Y2hpbmdcbiAgY29uc3Qgbm9ybWFsaXplVGV4dCA9ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKVxuICBjb25zdCBub3JtYWxpemVkRnVsbFRleHQgPSBub3JtYWxpemVUZXh0KGZ1bGxUZXh0KVxuICBcbiAgLy8gVHJ5IGRpZmZlcmVudCBzZWFyY2ggc3RyYXRlZ2llcyBpbiBvcmRlciBvZiByZWxpYWJpbGl0eVxuICBcbiAgLy8gU3RyYXRlZ3kgMTogRnVsbCBjb250ZXh0IG1hdGNoIChtb3N0IHJlbGlhYmxlKVxuICBpZiAoY29udGV4dF9iZWZvcmUgJiYgY29udGV4dF9hZnRlcikge1xuICAgIGNvbnN0IGZ1bGxQYXR0ZXJuID0gYCR7Y29udGV4dF9iZWZvcmV9JHtvcmlnaW5hbF90ZXh0fSR7Y29udGV4dF9hZnRlcn1gXG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdHRlcm4gPSBub3JtYWxpemVUZXh0KGZ1bGxQYXR0ZXJuKVxuICAgIFxuICAgIGxldCBmdWxsTWF0Y2ggPSBmdWxsVGV4dC5pbmRleE9mKGZ1bGxQYXR0ZXJuKVxuICAgIGlmIChmdWxsTWF0Y2ggPT09IC0xKSB7XG4gICAgICAvLyBUcnkgd2l0aCBub3JtYWxpemVkIHdoaXRlc3BhY2VcbiAgICAgIGZ1bGxNYXRjaCA9IG5vcm1hbGl6ZWRGdWxsVGV4dC5pbmRleE9mKG5vcm1hbGl6ZWRQYXR0ZXJuKVxuICAgICAgaWYgKGZ1bGxNYXRjaCAhPT0gLTEpIHtcbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIG9yaWdpbmFsIHRleHQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgYmVmb3JlTm9ybWFsaXplZCA9IG5vcm1hbGl6ZVRleHQoY29udGV4dF9iZWZvcmUpXG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gbm9ybWFsaXplZEZ1bGxUZXh0LmluZGV4T2YoYmVmb3JlTm9ybWFsaXplZClcbiAgICAgICAgaWYgKGJlZm9yZU1hdGNoICE9PSAtMSkge1xuICAgICAgICAgIGZ1bGxNYXRjaCA9IGJlZm9yZU1hdGNoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGZ1bGxNYXRjaCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZnVsbE1hdGNoICsgY29udGV4dF9iZWZvcmUubGVuZ3RoXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEZ1bGwgY29udGV4dCBtYXRjaCBmb3VuZCBhdCBwb3NpdGlvbjonLCBzdGFydClcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RyYXRlZ3kgMjogQmVmb3JlIGNvbnRleHQgKyBvcmlnaW5hbCB0ZXh0XG4gIGlmIChjb250ZXh0X2JlZm9yZSkge1xuICAgIGNvbnN0IGJlZm9yZVBhdHRlcm4gPSBgJHtjb250ZXh0X2JlZm9yZX0ke29yaWdpbmFsX3RleHR9YFxuICAgIGxldCBiZWZvcmVNYXRjaCA9IGZ1bGxUZXh0LmluZGV4T2YoYmVmb3JlUGF0dGVybilcbiAgICBcbiAgICBpZiAoYmVmb3JlTWF0Y2ggPT09IC0xKSB7XG4gICAgICAvLyBUcnkgd2l0aCBub3JtYWxpemVkIHdoaXRlc3BhY2VcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXR0ZXJuID0gbm9ybWFsaXplVGV4dChiZWZvcmVQYXR0ZXJuKVxuICAgICAgYmVmb3JlTWF0Y2ggPSBub3JtYWxpemVkRnVsbFRleHQuaW5kZXhPZihub3JtYWxpemVkUGF0dGVybilcbiAgICB9XG4gICAgXG4gICAgaWYgKGJlZm9yZU1hdGNoICE9PSAtMSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBiZWZvcmVNYXRjaCArIGNvbnRleHRfYmVmb3JlLmxlbmd0aFxuICAgICAgY29uc29sZS5sb2coJ+KchSBCZWZvcmUgY29udGV4dCBtYXRjaCBmb3VuZCBhdCBwb3NpdGlvbjonLCBzdGFydClcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RyYXRlZ3kgMzogT3JpZ2luYWwgdGV4dCArIGFmdGVyIGNvbnRleHRcbiAgaWYgKGNvbnRleHRfYWZ0ZXIpIHtcbiAgICBjb25zdCBhZnRlclBhdHRlcm4gPSBgJHtvcmlnaW5hbF90ZXh0fSR7Y29udGV4dF9hZnRlcn1gXG4gICAgbGV0IGFmdGVyTWF0Y2ggPSBmdWxsVGV4dC5pbmRleE9mKGFmdGVyUGF0dGVybilcbiAgICBcbiAgICBpZiAoYWZ0ZXJNYXRjaCA9PT0gLTEpIHtcbiAgICAgIC8vIFRyeSB3aXRoIG5vcm1hbGl6ZWQgd2hpdGVzcGFjZVxuICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdHRlcm4gPSBub3JtYWxpemVUZXh0KGFmdGVyUGF0dGVybilcbiAgICAgIGFmdGVyTWF0Y2ggPSBub3JtYWxpemVkRnVsbFRleHQuaW5kZXhPZihub3JtYWxpemVkUGF0dGVybilcbiAgICB9XG4gICAgXG4gICAgaWYgKGFmdGVyTWF0Y2ggIT09IC0xKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEFmdGVyIGNvbnRleHQgbWF0Y2ggZm91bmQgYXQgcG9zaXRpb246JywgYWZ0ZXJNYXRjaClcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBhZnRlck1hdGNoLCBlbmQ6IGFmdGVyTWF0Y2ggKyBvcmlnaW5hbF90ZXh0Lmxlbmd0aCB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdHJhdGVneSA0OiBFeGFjdCB0ZXh0IG1hdGNoIChmYWxsYmFjaylcbiAgbGV0IGV4YWN0TWF0Y2ggPSBmdWxsVGV4dC5pbmRleE9mKG9yaWdpbmFsX3RleHQpXG4gIGlmIChleGFjdE1hdGNoID09PSAtMSkge1xuICAgIC8vIFRyeSB3aXRoIG5vcm1hbGl6ZWQgd2hpdGVzcGFjZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcmlnaW5hbCA9IG5vcm1hbGl6ZVRleHQob3JpZ2luYWxfdGV4dClcbiAgICBleGFjdE1hdGNoID0gbm9ybWFsaXplZEZ1bGxUZXh0LmluZGV4T2Yobm9ybWFsaXplZE9yaWdpbmFsKVxuICB9XG4gIFxuICBpZiAoZXhhY3RNYXRjaCAhPT0gLTEpIHtcbiAgICBjb25zb2xlLmxvZygn4pyFIEV4YWN0IHRleHQgbWF0Y2ggZm91bmQgYXQgcG9zaXRpb246JywgZXhhY3RNYXRjaClcbiAgICByZXR1cm4geyBzdGFydDogZXhhY3RNYXRjaCwgZW5kOiBleGFjdE1hdGNoICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICB9XG4gIFxuICAvLyBTdHJhdGVneSA1OiBGdXp6eSBtYXRjaGluZyBmb3Igc2ltaWxhciB0ZXh0XG4gIGNvbnN0IHdvcmRzID0gb3JpZ2luYWxfdGV4dC50cmltKCkuc3BsaXQoL1xccysvKVxuICBpZiAod29yZHMubGVuZ3RoID4gMikge1xuICAgIC8vIFRyeSB0byBmaW5kIGEgc3Vic3RyaW5nIHdpdGggbW9zdCBvZiB0aGUgd29yZHNcbiAgICBjb25zdCBmaXJzdEhhbGYgPSB3b3Jkcy5zbGljZSgwLCBNYXRoLmNlaWwod29yZHMubGVuZ3RoIC8gMikpLmpvaW4oJyAnKVxuICAgIGNvbnN0IHNlY29uZEhhbGYgPSB3b3Jkcy5zbGljZShNYXRoLmZsb29yKHdvcmRzLmxlbmd0aCAvIDIpKS5qb2luKCcgJylcbiAgICBcbiAgICBsZXQgZnV6enlNYXRjaCA9IGZ1bGxUZXh0LmluZGV4T2YoZmlyc3RIYWxmKVxuICAgIGlmIChmdXp6eU1hdGNoID09PSAtMSkge1xuICAgICAgZnV6enlNYXRjaCA9IGZ1bGxUZXh0LmluZGV4T2Yoc2Vjb25kSGFsZilcbiAgICB9XG4gICAgXG4gICAgaWYgKGZ1enp5TWF0Y2ggIT09IC0xKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEZ1enp5IG1hdGNoIGZvdW5kIGF0IHBvc2l0aW9uOicsIGZ1enp5TWF0Y2gpXG4gICAgICByZXR1cm4geyBzdGFydDogZnV6enlNYXRjaCwgZW5kOiBmdXp6eU1hdGNoICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RyYXRlZ3kgNjogV29yZC1ieS13b3JkIHNlYXJjaCAobGFzdCByZXNvcnQpXG4gIGNvbnN0IGZpcnN0V29yZCA9IHdvcmRzWzBdXG4gIGlmIChmaXJzdFdvcmQgJiYgZmlyc3RXb3JkLmxlbmd0aCA+IDMpIHtcbiAgICBjb25zdCB3b3JkTWF0Y2ggPSBmdWxsVGV4dC5pbmRleE9mKGZpcnN0V29yZClcbiAgICBpZiAod29yZE1hdGNoICE9PSAtMSkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBGaXJzdCB3b3JkIG1hdGNoIGZvdW5kIGF0IHBvc2l0aW9uOicsIHdvcmRNYXRjaClcbiAgICAgIHJldHVybiB7IHN0YXJ0OiB3b3JkTWF0Y2gsIGVuZDogd29yZE1hdGNoICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIGRpc3RyaWJ1dGUgY29tbWVudHMgZXZlbmx5IGluc3RlYWQgb2YgcG9zaXRpb24gMFxuICBjb25zb2xlLndhcm4oJ+KdjCBDb3VsZCBub3QgZmluZCB0ZXh0IHBvc2l0aW9uIGZvciBjb21tZW50OicsIGNvbW1lbnQuY29tbWVudF9pZClcbiAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gZGlzdHJpYnV0ZWQgcG9zaXRpb25pbmcnKVxuICBcbiAgLy8gVXNlIGEgaGFzaCBvZiB0aGUgY29tbWVudCBJRCB0byBjcmVhdGUgY29uc2lzdGVudCBidXQgZGlzdHJpYnV0ZWQgcG9zaXRpb25pbmdcbiAgY29uc3QgaGFzaCA9IGNvbW1lbnQuY29tbWVudF9pZC5zcGxpdCgnJykucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgYSA9ICgoYSA8PCA1KSAtIGEpICsgYi5jaGFyQ29kZUF0KDApXG4gICAgcmV0dXJuIGEgJiBhXG4gIH0sIDApXG4gIGNvbnN0IGZhbGxiYWNrUG9zaXRpb24gPSBNYXRoLmFicyhoYXNoKSAlIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZnVsbFRleHQubGVuZ3RoIC8gNCkpXG4gIFxuICByZXR1cm4geyBzdGFydDogZmFsbGJhY2tQb3NpdGlvbiwgZW5kOiBmYWxsYmFja1Bvc2l0aW9uICsgb3JpZ2luYWxfdGV4dC5sZW5ndGggfVxufSAiXSwibmFtZXMiOlsiY29udmVydFRvV29yZExpa2VDb21tZW50IiwibGVnYWxDb21tZW50IiwiZnVsbFRleHQiLCJzZXZlcml0eU1hcCIsInN0YXJ0IiwiZW5kIiwiZmluZFRleHRQb3NpdGlvbiIsImlkIiwiY29tbWVudF9pZCIsInRleHQiLCJjb21tZW50X3RpdGxlIiwiY29tbWVudF9kZXRhaWxzIiwicmVjb21tZW5kYXRpb24iLCJhdXRob3IiLCJzZXZlcml0eSIsImNvbW1lbnQiLCJjb250ZXh0X2JlZm9yZSIsIm9yaWdpbmFsX3RleHQiLCJjb250ZXh0X2FmdGVyIiwiY29uc29sZSIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3JtYWxpemVUZXh0IiwicmVwbGFjZSIsInRyaW0iLCJub3JtYWxpemVkRnVsbFRleHQiLCJmdWxsUGF0dGVybiIsIm5vcm1hbGl6ZWRQYXR0ZXJuIiwiZnVsbE1hdGNoIiwiaW5kZXhPZiIsImJlZm9yZU5vcm1hbGl6ZWQiLCJiZWZvcmVNYXRjaCIsImxlbmd0aCIsImJlZm9yZVBhdHRlcm4iLCJhZnRlclBhdHRlcm4iLCJhZnRlck1hdGNoIiwiZXhhY3RNYXRjaCIsIm5vcm1hbGl6ZWRPcmlnaW5hbCIsIndvcmRzIiwic3BsaXQiLCJmaXJzdEhhbGYiLCJzbGljZSIsIk1hdGgiLCJjZWlsIiwiam9pbiIsInNlY29uZEhhbGYiLCJmbG9vciIsImZ1enp5TWF0Y2giLCJmaXJzdFdvcmQiLCJ3b3JkTWF0Y2giLCJ3YXJuIiwiaGFzaCIsInJlZHVjZSIsImEiLCJiIiwiY2hhckNvZGVBdCIsImZhbGxiYWNrUG9zaXRpb24iLCJhYnMiLCJtYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/index.ts\n"));

/***/ })

});